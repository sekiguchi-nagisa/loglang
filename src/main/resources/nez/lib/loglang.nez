// syntax definition of Loglang
// written by Nez

// lexical rule
EOF = !.

W = [0-9a-zA-Z_]+

IDENTIFIER = [a-zA-Z_][0-9a-zA-Z_]*

PATTERN = 'pattern' !W
STATE   = 'state'   !W
VAR     = 'var'     !W
CASE    = 'case'    !W
TRUE    = 'true'    !W
FALSE   = 'false'   !W


KEYWORD = PATTERN
        / STATE
        / VAR
        / CASE
        / TRUE
        / FALSE

_ = ([ \t\r\n] / COMMENT)*

WS = ([ \t] / COMMENT)*

COMMENT = '//' (![\r\n] .)*

LINE_END
    = WS (EOF / [\r\n] / ';')

File
    = { _ @PatternDefinition _ @MatchStatement _ #Root }

PATTERN_BEGIN
    = '[[' WS '\n'

PATTERN_END
    = ']]' WS '\n'

// peg definition
PatternDefinition
    = PATTERN_BEGIN {  (_ @RuleExpr)+ _ #PatternDefinition } PATTERN_END

RuleExpr
    = { @{ IDENTIFIER #Name } @TypeAnnotation _ '=' _ @ChoiceExpr #RuleExpr }

TypeAnnotation
    = _ ':' _ { IDENTIFIER #Name }
    / {#Empty}

ChoiceExpr
    = SequenceExpr {@ _ '/' _ @SequenceExpr #ChoiceExpr }*

SequenceExpr
    = LabeledExpr {@ _ @LabeledExpr #SequenceExpr }*

LabeledExpr
    = {'$' @{ IDENTIFIER #Name } _ ':' _ @PrefixExpr  #LabeledExpr }
    / PrefixExpr

PrefixExpr
    = { ('&' #AndExpr / '!' #NotExpr ) _ @SuffixExpr }
    / SuffixExpr

SuffixExpr
    = PrimaryExpr {@ _ ('*' #ZeroMoreExpr / '+' #OneMoreExpr / '?' #OptionalExpr) }*

PrimaryExpr
    = '(' _ ChoiceExpr _ ')'
    / { IDENTIFIER !(_ [:=<]) #NonTerminalExpr }
    / { '.' #AnyExpr }
    / { '\''  ('\\\'' / '\\\\' / !['\n\r] .)*  '\'' #StringExpr }
    / Charset

Charset
       = { '[' (@({ CHAR #Class } ({@ '-' @({ CHAR #Class }) #List })?))* ']'  #CharClassExpr }

CHAR
    = '\\u' HEX HEX HEX HEX
    / '\\x' HEX HEX
    / '\\n'
    / '\\t'
    / '\\\\'
    / '\\r'
    / '\\v'
    / '\\f'
    / '\\-'
    / '\\]'
    / !(']') .

HEX
    = [0-9A-Fa-f]


// language definition

MatchStatement
    = { ( _ @CaseStatement)+ #Match }

CaseStatement
    = { CASE _ @{ IDENTIFIER #CasePattern } @CaseBlock #CaseStatement }

CaseBlock
    = _ { '{' _ @StateDefinitions _ @Statements _ '}' #CaseBlock } _

StateDefinitions
    = { ( _ @StateDefinition)* #States }

StateDefinition
    = { STATE _ @Variable _ '=' _ @Expression LINE_END  #State }

Statements
    = { ( _ @Statement LINE_END)* #Statements }

Statement
    = VarDecl / Expression

VarDecl
    = { VAR _ @Variable _ '=' _ @Expression #VarDecl }

Expression
    = Float / Integer / Bool / Variable

NUM = '0' / [1-9][0-9]*

Integer
    = { NUM #Integer }

FLOAT_SUFFIX
    = [eE] [+-]? NUM

Float
    = { NUM '.' [0-9]+ FLOAT_SUFFIX? #Float }

Bool
    = { TRUE #True / FALSE #False }

Variable
    = { !KEYWORD IDENTIFIER #Variable }
